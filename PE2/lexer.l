%{
/*
 * lexer.l - LEX/FLEX Lexer for simplified C subset
 *
 * Responsibilities:
 *  - Tokenize keywords, identifiers, numbers, operators, punctuation
 *  - Track line numbers for error reporting
 *  - Ignore whitespace and comments (both // and /* *\/)
 */

#include "parser.tab.h"   /* token definitions generated by Bison */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


%}

/* Tell flex NOT to require a yywrap() function */
%option noyywrap
%option yylineno

/* ── Named patterns ── */
DIGIT    [0-9]
LETTER   [a-zA-Z_]
ID       {LETTER}({LETTER}|{DIGIT})*
INT_NUM  {DIGIT}+
FLOAT_NUM {DIGIT}+\.{DIGIT}+

%%

 /* ── Whitespace ── */
[ \t\r]+    { /* ignore horizontal whitespace */ }
\n          { yylineno++; }

 /* ── Single-line comment ── */
"//"[^\n]*  { /* ignore until end of line */ }

 /* ── Multi-line comment (non-greedy via state trick) ── */
"/*"        {
                int c;
                while (1) {
                    c = input();
                    if (c == '\n') yylineno++;
                    if (c == '*') {
                        c = input();
                        if (c == '/') break;
                        if (c == '\n') yylineno++;
                        if (c == EOF) {
                            fprintf(stderr, "Unterminated comment\n");
                            break;
                        }
                    }
                    if (c == EOF) break;
                }
            }

 /* ── Keywords (must come BEFORE the ID rule) ── */
"int"       { return INT;    }
"float"     { return FLOAT;  }
"char"      { return CHAR;   }
"double"    { return DOUBLE; }
"if"        { return IF;     }
"else"      { return ELSE;   }
"do"        { return DO;     }
"while"     { return WHILE;  }

 /* ── Identifiers ── */
{ID}        { yylval.str = strdup(yytext); return ID; }

 /* ── Numeric literals ── */
{FLOAT_NUM} { yylval.str = strdup(yytext); return NUM; }
{INT_NUM}   { yylval.str = strdup(yytext); return NUM; }

 /* ── Relational operators ── */
"=="        { return EQ;  }
"!="        { return NEQ; }
"<="        { return LE;  }
">="        { return GE;  }
"<"         { return LT;  }
">"         { return GT;  }

 /* ── Arithmetic operators (single-char, returned as literals) ── */
"+"         { return '+'; }
"-"         { return '-'; }
"*"         { return '*'; }
"/"         { return '/'; }
"%"         { return '%'; }

 /* ── Assignment ── */
"="         { return '='; }

 /* ── Punctuation ── */
";"         { return ';'; }
","         { return ','; }
"("         { return '('; }
")"         { return ')'; }
"{"         { return '{'; }
"}"         { return '}'; }

 /* ── Unknown character ── */
.           {
                fprintf(stderr,
                    "Syntax error at line %d, token : '%s'\n",
                    yylineno, yytext);
                exit(1);
            }

%%
